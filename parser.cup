/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import cup.example.*;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, UMINUS, TIMES, LPAREN, RPAREN;
terminal Integer   	NUMBER;        // our scanner provides numbers as integers
terminal BOOLEAN, COLEQ, COMMA, COLON,ARRAY,FALSE,WHILE,REACT,UNION,UNTIL,ACTOR;
terminal CLASS,MINUSMINUS,LEQ,NEQ,AND,DOT,DIV,NOT,MOD,GEQ,NEW,ALL,DEF,ACT,INT;
terminal SET,VAL,VAR,ENSURING,SUBSETOF,DOUBLEARROW,EQEQ,NULL,ELSE,LOOP,TRUE,UNIT;
terminal CASE,INTERSECT,UNDERLINE,RANNOT,ATSIGN,DOLLAR,LANNOT,EQEQEQ,IMPORT,OBJECT;
terminal STRING,RSQUAREBRACKET,LSQUAREBRACKET,OR,GT,EQ,LT,EX,IF,DO,RCURLYBRACKET, LCURLYBRACKET, EXTENDS;
terminal String ID;
 

/* Non terminals */
/*non terminal            expr_list;
non terminal Integer    expr; */
non terminal program;     // used to store evaluated subexpressions
non terminal Top;
non terminal ScalaProgram;
non terminal Import;
non terminal ImportDeclaration;
non terminal ImportDeclarations;
non terminal Predicates;
non terminal ScalaObject;
non terminal ImportExprs; 
non terminal ImportExpr;
non terminal PathElem;
non terminal PredStats;
non terminal PredStat;
non terminal Expr;
non terminal VarDeclaration;
non terminal Variable;
non terminal Type;
non terminal Declarations;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;
precedence left OR;
precedence left AND;
precedence left EQ, COLEQ;
precedence left NEQ;
precedence right ELSE;
precedence right DOUBLEARROW;
precedence nonassoc GT, LEQ, LT, GEQ, EQEQ, EQEQEQ, ATSIGN, UNTIL;
precedence left PLUS, MINUS, MINUSMINUS;
precedence left TIMES, DIV, MOD;
precedence left NOT, DOLLAR;
precedence left	DOT;
precedence left LPAREN;


/* The grammar rules */
start with Top;
/*expr_list ::= expr_list expr:e SEMI         {: System.out.println(e); :}
            | expr:e SEMI                   {: System.out.println(e); :}
            ;
            
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;        :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;        :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;        :}
             | MINUS expr:e                 {: RESULT = -e;           :}
             %prec UMINUS
             | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
             | NUMBER:n	                     {: RESULT = n;           :}
             ;*/
       
Top               ::= ScalaProgram:scp
                   //{: RESULT = scp; :}
                   ;
ScalaProgram      ::= Import ScalaObject:so
                   //{: RESULT = so; :}
                   |  Predicates:ps Import ScalaObject:so
                   //{: RESULT =ps; so;   :} //ver o que tem para retornar
                   ;

ScalaObject       ::= OBJECT ID:id LCURLYBRACKET Declarations:ds RCURLYBRACKET
                   //{: RESULT = id; ds; :} //ver o que tem para retornar
                   ;
                  
                   
Import            ::= 
                   |  ImportDeclarations
                   ;
                   
ImportDeclaration ::= IMPORT ImportExprs
                   ;
                   
ImportDeclarations::= ImportDeclaration
                   |  ImportDeclarations ImportDeclaration 
                   ;  
                   
Predicates        ::= LANNOT PredStats:ps RANNOT
                   //{: RESULT = ps; :}
                   ;
ImportExprs       ::= ImportExpr
                   |  ImportExprs COMMA ImportExpr
                   ;
                   
ImportExpr        ::= PathElem:pe
                   |  ImportExpr DOT PathElem:pe
                   ;
                   
PathElem          ::= ID:id
                   |  UNDERLINE
                   ; //isso aqui quer dizer import java.io._

/*Type              ::= UNIT:s
                   //{: RESULT = s :}
                   |  ARRAY:a LSQUAREBRACKET Type:t RSQUAREBRACKET
                   //{: RESULT = a :}
                   |  SET:s LSQUAREBRACKET Type:t RSQUAREBRACKET
                   //{: RESULT = s :}                   
                   |  INT:i
                  // {: RESULT = i :}
                   |  STRING:s
                   //{: RESULT = s :}
                   |  BOOLEAN:b
                   //{: RESULT = b :}
                   |  ID:id
                   //{: RESULT = id :}                   
                   ; 
*/

VarDeclaration    ::= VAR Variable:v COLON Type:t EQ Expr:e
                   //{: RESULT = new VarDeclaration(v.name(), t, e); :}
                   |  VAL Variable:v COLON Type:t EQ Expr:e
                   //{: RESULT = new VarDeclaration(v.name(), t, e); :}
                   ;
                   
Variable          ::= ID:id
                   //{: RESULT = id; :}
                   |  DOLLAR ID:id
                   //{: RESULT = id; :}
                   ;      
